{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":4249463280923577022,"abi":{"parameters":[{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature_unique","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"old_signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"old_amount","type":{"kind":"field"},"visibility":"private"},{"name":"witnesses","type":{"kind":"array","length":16,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"private"},{"name":"leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"action_index","type":{"kind":"field"},"visibility":"private"},{"name":"token","type":{"kind":"field"},"visibility":"public"},{"name":"unique","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"new_leaf","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"merkle_root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"amount_relayer","type":{"kind":"field"},"visibility":"public"},{"name":"receiver","type":{"kind":"field"},"visibility":"public"},{"name":"relayer","type":{"kind":"field"},"visibility":"public"},{"name":"is_deposit","type":{"kind":"array","length":1,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"approve","type":{"kind":"array","length":1,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"call","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"param_witnesses":{"action_index":[{"start":770,"end":771}],"amount":[{"start":868,"end":869}],"amount_relayer":[{"start":869,"end":870}],"approve":[{"start":873,"end":874}],"call":[{"start":874,"end":906}],"is_deposit":[{"start":872,"end":873}],"leaf_index":[{"start":769,"end":770}],"merkle_root":[{"start":836,"end":868}],"new_leaf":[{"start":804,"end":836}],"old_amount":[{"start":256,"end":257}],"old_signature":[{"start":128,"end":192}],"pub_key_x":[{"start":192,"end":224}],"pub_key_y":[{"start":224,"end":256}],"receiver":[{"start":870,"end":871}],"relayer":[{"start":871,"end":872}],"signature":[{"start":0,"end":64}],"signature_unique":[{"start":64,"end":128}],"token":[{"start":771,"end":772}],"unique":[{"start":772,"end":804}],"witnesses":[{"start":257,"end":769}]},"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"1d3BjmDJcR3Qf5k1Fy8jMiIz+SuGF4ItAwIEybC0I/jvbpvs1khdzUE/8VCVuxlM50R2V9x3q2pOvfnDL//4z//j7/71H/75n/7ll9//4Zd99i+//29/+OVf/vff/dP/+/t/+de/+z//+svvz/P87pe//6f/+eWvxvrj7375X//wj3//y+/z/PG//+7LkfOzR778s58/Mn7+SHx4JMfXIzO+O5I/f2T+/JH6+SP94ZHqr0f6fHdk/fyR/fNHzk8fGR9/9Pe3D+X57rc/xs8fiZ8/8uFHfzzj6wdmPPl8d2i+OVRvDvWbQ+vNof3xoRXfDu3vP6znxaF43hwabw59uA9jnG9/EPHs7w7lm0PzzaF6c6jfHFpvDu03h86LQ/m8OTTeHHqzEflmI/LNRuSbjcg3G5FvNiLfbES+2Yj5ZiPmm42YbzZivtmI+WYj5puNmG82Yr7ZiPlmI+abjag3G1FvNqLebES92Yj6eCOizrdDK7879PFGZOXXQ/l9E1a/ObTeHNpvDp0Xh/rjjaj59fPQUat+feh33/3inP11Qs5fT1gf/OK1v35Ydvzbv3f0ny4zPtNl4jNdJj/TZeZ//jL17K+XqS//2l9d5v9PKD6h+YTFJ2w+4egJ6+ETBp8QfELyCTzT6+NM91lfJ6xfH/poQsfz9RHW8evvW/15QvMJi0/YfMLRE/bDJww+IfiE5BMmn8AzvXmm918l0/Ftwhx/+VOrXN++lZrrV99LHX+6zf5Utzmf6Tbn+VS3+Ws8g/rrp9mdv/7K9sVt4lPdJj/Vbeanus1f4ZmZ+Xy7Tcdfvk2M/fXxFzGe/3ib/lS3WZ/qNvsT3WY8z89G/E+n8tWp+epUvTrVr06tV6f2q1Mf1+Dub6f2+Y0vjmZV/fkXz1q/sTXn2ycsX/5jxh9/9d2X73/p+LI0377PWf/xWzVf/nPlc+/Vx71Xj3uvnvdefd579br36n3v1de9V9/3Xv3eNo172zTubdO4t03j3jaNe9s07m3TuLdN4942jXvbNO5t07y3TfPeNs172zTvbdO8t03z3jbNe9s0723TvLdN8942nfe26by3Tee9bTrvbdN5b5vOe9t03tum8942nfe26by3TeveNq1727TubdO6t03r3jate9u07m3TurdN6942rXvbtO9t0763TfveNu1727TvbdO+t0373jbte9u0723TvrdN171tuu5t03Vvm/7gx4fP8/U240R/0qvPe69e91697736uvfq+96rn2uv/oOfVr/i6uPeq8e9V7+3Tfe9bbrvbdN9b5vue9t039um+942Pfe26bm3Tc+9bXrubdNzb5uee9v03Num5942Pfe26bm2TcdzbZuO59o2Hc+1bTqea9t0PNe26XiubdPxXNum47m2TcdzbZuO5942Hfe26bi3Tce9bTrubdNxb5uOe9t03Num4942Hfe26bi3TePeNo172zTubdO4t03j3jaNe9s07m3TuLdN4942jXvbNO9t07y3TfPeNs172zTvbdO8t03z3jb9wbuQTn77n1OdHp/06vveq59rr/6DdyFdcfVx79Xj3qvnvVef91697r1633v1e9t03tum8942rXvbtO5t07q3TeveNq1727TubdO6t03r3jate9u07m3TvrdN+9427XvbtO9t0763TfveNu1727TvbdO+t0373jZd97bpurdN171tuu5t03Vvm65723Td26br3jZd97bpurdN971tuu9t031vm+5723Tf26b73jbd97bpvrdN971tuu9t03Nvm5572/Tc26bn3jY997bpubdNz71teu5t03Nvm55r2zSea9s0fvAupP386urrL9+mRn4dUV++X//rX/ynET9ovXP+fCpG/NaIyq9/OlXd34/4sJ0i+uvvIrLG96c+LIbInt9OrQ9+Ox8+k2OOrzeMej644YePw6jx7Q+h5gc3/PBJFL3j66k1nu9PffgQiDW//b7WR7+vD/MX+9sSx+747tTHLy75zVPj1al4dSpfnZqvTtWrU/3q1Hp1ar869Wo34tVuxKvdiFe7Ea92I17tRrzajXi1G/FqN+LVbsSr3chXu5GvdiNf7Ua+2o18tRv5ajfy1W7kq93IV7uRr3ZjvtqN+YPdWN9OnWd9fypencpXp+arU/XqVL86tV6d2q9OnTen6nl16tVu1KvdqFe7Ua92o17tRr3ajXq1G/VqN+rVbvSr3ehXu9GvdqNf7Ua/2o1+tRv9ajf61W70q93oV7uxXu3GerUb69VufKx/4vzbV4hfvp/w/an56lS9OtWvTn24G/msr18v53O+/xr2Y2SRXz4J+Hoqn/3HT/ktlY+RxRVX/xhZ3HH1ce/V496r571Xn/deve69et979XXv1e9t031vm5572/Tc26bn3jY9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","file_map":{"1":{"source":"trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u16 { fn eq(self, other: u16) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i16 { fn eq(self, other: i16) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, N> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<N> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, N> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n","path":"std/cmp.nr"},"16":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n    \n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(_self: Self, _bit_size: u32) -> [u1] {}\n    \n    #[builtin(to_be_bits)]\n    fn __to_be_bits(_self: Self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(_self: Self, _bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n    \n    #[builtin(to_be_radix)]\n    fn __to_be_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"37":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\n\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 {\n            lo: lo as Field,\n            hi: hi as Field,\n        }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo,hi)\n    }\n\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 {\n            lo,\n            hi,\n        }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0;16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0;16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<N>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1; \n        if N <= 18 {\n            for i in 0..N-2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N-1 {           \n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 {\n            lo: lo as Field,\n            hi: hi as Field,\n        }\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            if ascii < 71 {\n                ascii - 55\n            } else {\n                ascii - 87\n            }\n            \n        } as Field\n    }\n\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if self < b {\n            (U128::from_u64s_le(0, 0), self)\n        } else {\n            //TODO check if this can overflow?\n            let (q,r) = self.unconstrained_div(b * U128::from_u64s_le(2,0));\n            let q_mul_2 = q * U128::from_u64s_le(2,0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::from_u64s_le(1,0), r - b)\n            }\n\n        }  \n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f-lo) / pow64;\n        U128 {\n            lo,\n            hi,\n        }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo+self.hi*pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64))as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift left with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift right with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n","path":"std/uint128.nr"},"39":{"source":"use dep::std;\nuse dep::std::slice;\n\nfn main(\n    // use signature to never reveal private key, usefull to use external service like sindri\n    signature: [u8; 64],\n    signature_unique: [u8; 64],\n    old_signature: [u8; 64],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    old_amount: Field,\n    // size 16, bigger array failed to prove in js\n    witnesses: [[u8; 32]; 16],\n    leaf_index: Field,\n    action_index: Field,\n    token: pub Field,\n    // unique need to store stoken, action by token, to retrieve data from wallet\n    unique: pub [u8; 32],\n    // new leaf act as nullifer\n    new_leaf: pub [u8; 32],\n    merkle_root: pub [u8; 32],\n    amount: pub Field,\n    amount_relayer: pub Field,\n    receiver: pub Field,\n    relayer: pub Field,\n    is_deposit: pub [u8; 1],\n    approve: pub [u8; 1],\n    // hash of call\n    call: pub [u8; 32]\n) {\n    // must be an action index > 0\n    assert(action_index != 0);\n    assert(amount != 0);\n    assert(receiver != 0);\n    if (relayer != 0) {\n        assert(amount_relayer != 0);\n    }\n    let mut newAmount= 0;\n    if is_deposit == [1] {\n        let emptyCall :[u8; 32] = [0; 32];\n        // we can't make call on deposit\n        assert(emptyCall == call);\n        // no approve on deposit\n        assert(approve == [0]);\n        // deposit add amount and substract relayer part\n        newAmount = old_amount + amount - amount_relayer;\n    } else {\n        // withdraw substract amount and  relayer part\n        newAmount = old_amount - amount - amount_relayer;\n    }\n\n    let amountAfter = U128::from_integer(newAmount);\n    let zero = U128::from_integer(0);\n    // new amount can't be negative (can't withdraw more than balance)\n    assert(amountAfter >= zero, \"Amount can't be negative\");\n\n    // use blake 3 to hash\n    let hash_message:[u8;32] = get_leaf_hash(\n        pub_key_x,\n        pub_key_y,\n        field_to_bytes(action_index),\n        field_to_bytes(token),\n        field_to_bytes(newAmount)\n    );\n    let hash_unique:[u8;32] = get_unique_hash(\n        pub_key_x,\n        pub_key_y,\n        field_to_bytes(action_index),\n        field_to_bytes(token)\n    );\n\n    // the user only need to sign with is private key to generate merkle leaf, so we never reveal private key\n    let valid_signature = std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, signature, hash_message);\n    assert(valid_signature);\n    let valid_signature_unique = std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, signature_unique, hash_unique);\n    assert(valid_signature_unique);\n\n    // we use hash_signature so it will be difficult to guess the hash if we don'r have the private key to sign\n    let hash_signature = std::hash::blake3(signature);\n    let hash_signature_unique = std::hash::blake3(signature_unique);\n\n    // check new leaf match hash generated\n    assert(new_leaf == hash_signature);\n    assert(unique == hash_signature_unique);\n\n    if (action_index == 1) {\n        // the first deposit don't need to prove old actions\n        // if first action so the previous balance is zero\n        assert(old_amount == 0);\n    } else {\n        let oldAction = action_index - 1;\n        // use blake 3 to hash\n        let old_data:[u8;32] = get_leaf_hash(\n            pub_key_x,\n            pub_key_y,\n            field_to_bytes(oldAction),\n            field_to_bytes(token),\n            field_to_bytes(old_amount)\n        );\n        let valid_old_signature = std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, old_signature, old_data);\n        assert(valid_old_signature, \"Invalid old signature\");\n        let old_leaf = std::hash::blake3(old_signature);\n        let computed_root = compute_merkle_root(old_leaf, leaf_index, witnesses);\n        assert(computed_root == merkle_root);\n    }\n}\n\n// update of noir implementation to use sha (best ratio perf/gas for solidity)\nfn compute_merkle_root<N>(leaf: [u8; 32], index: Field, hash_path: [[u8; 32]; N]) -> [u8; 32] {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        let mut arr:[u8;64]= [0; 64];\n        for i in 0..32 {\n            arr[i] = hash_left[i];\n            arr[i+32]=hash_right[i];\n        }\n        current = std::hash::sha256(arr);\n    }\n    current\n}\n\nfn field_to_bytes(input: Field) -> [u8; 32] {\n    let input_to_bytes:[u8] = input.to_le_bytes(32);\n    let mut result :[u8;32] = [0; 32];\n    for i in 0..32 {\n        result[i] = input_to_bytes[i];\n    }\n    result\n}\n\nfn get_leaf_hash(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    action_index: [u8; 32],\n    token: [u8; 32],\n    amount: [u8; 32]\n) -> [u8; 32] {\n    let mut array_concat:[u8;160] = [0; 160];\n\n    for i in 0..32 {\n        array_concat[i] = pub_key_x[i];\n        array_concat[i+32] = pub_key_y[i];\n        array_concat[i+64] = action_index[i];\n        array_concat[i+96] = token[i];\n        array_concat[i+128] = amount[i];\n    }\n    std::hash::blake3(array_concat)\n}\n\nfn get_unique_hash(pub_key_x: [u8; 32], pub_key_y: [u8; 32], action_index: [u8; 32], token: [u8; 32]) -> [u8; 32] {\n    let mut array_concat:[u8;128] = [0; 128];\n\n    for i in 0..32 {\n        array_concat[i] = pub_key_x[i];\n        array_concat[i+32] = pub_key_y[i];\n        array_concat[i+64] = action_index[i];\n        array_concat[i+96] = token[i];\n    }\n    std::hash::blake3(array_concat)\n}\n\n","path":"/home/eddy/pi-wallet/packages/foundry/noir/src/main.nr"}}}