{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":11713909192052660095,"abi":{"parameters":[{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature_unique","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"old_signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"old_amount","type":{"kind":"field"},"visibility":"private"},{"name":"witnesses","type":{"kind":"array","length":16,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"private"},{"name":"leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"action_index","type":{"kind":"field"},"visibility":"private"},{"name":"token","type":{"kind":"field"},"visibility":"public"},{"name":"unique","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"new_leaf","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"merkle_root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"amount_relayer","type":{"kind":"field"},"visibility":"public"},{"name":"receiver","type":{"kind":"field"},"visibility":"public"},{"name":"relayer","type":{"kind":"field"},"visibility":"public"},{"name":"is_deposit","type":{"kind":"array","length":1,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"approve","type":{"kind":"array","length":1,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"call","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"param_witnesses":{"action_index":[{"start":770,"end":771}],"amount":[{"start":868,"end":869}],"amount_relayer":[{"start":869,"end":870}],"approve":[{"start":873,"end":874}],"call":[{"start":874,"end":906}],"is_deposit":[{"start":872,"end":873}],"leaf_index":[{"start":769,"end":770}],"merkle_root":[{"start":836,"end":868}],"new_leaf":[{"start":804,"end":836}],"old_amount":[{"start":256,"end":257}],"old_signature":[{"start":128,"end":192}],"pub_key_x":[{"start":192,"end":224}],"pub_key_y":[{"start":224,"end":256}],"receiver":[{"start":870,"end":871}],"relayer":[{"start":871,"end":872}],"signature":[{"start":0,"end":64}],"signature_unique":[{"start":64,"end":128}],"token":[{"start":771,"end":772}],"unique":[{"start":772,"end":804}],"witnesses":[{"start":257,"end":769}]},"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"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","file_map":{"1":{"source":"trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u16 { fn eq(self, other: u16) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i16 { fn eq(self, other: i16) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, N> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<N> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, N> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n","path":"std/cmp.nr"},"16":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n    \n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(_self: Self, _bit_size: u32) -> [u1] {}\n    \n    #[builtin(to_be_bits)]\n    fn __to_be_bits(_self: Self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(_self: Self, _bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n    \n    #[builtin(to_be_radix)]\n    fn __to_be_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"37":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\n\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 {\n            lo: lo as Field,\n            hi: hi as Field,\n        }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo,hi)\n    }\n\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 {\n            lo,\n            hi,\n        }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0;16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0;16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<N>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1; \n        if N <= 18 {\n            for i in 0..N-2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N-1 {           \n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 {\n            lo: lo as Field,\n            hi: hi as Field,\n        }\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            if ascii < 71 {\n                ascii - 55\n            } else {\n                ascii - 87\n            }\n            \n        } as Field\n    }\n\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if self < b {\n            (U128::from_u64s_le(0, 0), self)\n        } else {\n            //TODO check if this can overflow?\n            let (q,r) = self.unconstrained_div(b * U128::from_u64s_le(2,0));\n            let q_mul_2 = q * U128::from_u64s_le(2,0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::from_u64s_le(1,0), r - b)\n            }\n\n        }  \n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f-lo) / pow64;\n        U128 {\n            lo,\n            hi,\n        }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo+self.hi*pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64))as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift left with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift right with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n","path":"std/uint128.nr"},"39":{"source":"use dep::std;\nuse dep::std::slice;\n\nfn main(\n    // use signature to never reveal private key, usefull to use external service like sindri\n    signature: [u8; 64],\n    signature_unique: [u8; 64],\n    old_signature: [u8; 64],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    old_amount: Field,\n    // size 16, bigger array failed to prove in js\n    witnesses: [[u8; 32]; 16],\n    leaf_index: Field,\n    action_index: Field,\n    token: pub Field,\n    // unique need to store stoken, action by token, to retrieve data from wallet\n    unique: pub [u8; 32],\n    // new leaf act as nullifer\n    new_leaf: pub [u8; 32],\n    merkle_root: pub [u8; 32],\n    amount: pub Field,\n    amount_relayer: pub Field,\n    receiver: pub Field,\n    relayer: pub Field,\n    is_deposit: pub [u8; 1],\n    approve: pub [u8; 1],\n    // hash of call\n    call: pub [u8; 32]\n) {\n    // must be an action index > 0\n    assert(action_index != 0);\n    assert(amount != 0);\n    assert(receiver != 0);\n    if (relayer != 0) {\n        assert(amount_relayer != 0);\n    }\n    let mut newAmount= 0;\n    if is_deposit == [1] {\n        let emptyCall :[u8; 32] = [0; 32];\n        // we can't make call on deposit\n        assert(emptyCall == call);\n        // no approve on deposit\n        assert(approve == [0]);\n        // deposit add amount and substract relayer part\n        newAmount = old_amount + amount - amount_relayer;\n    } else {\n        // withdraw substract amount and  relayer part\n        newAmount = old_amount - amount - amount_relayer;\n    }\n\n    let amountAfter = U128::from_integer(newAmount);\n    let zero = U128::from_integer(0);\n    // new amount can't be negative (can't withdraw more than balance)\n    assert(amountAfter >= zero, \"Amount can't be negative\");\n\n    // use blake 3 to hash\n    let hash_message:[u8;32] = get_leaf_hash(\n        pub_key_x,\n        pub_key_y,\n        field_to_bytes(action_index),\n        field_to_bytes(token),\n        field_to_bytes(newAmount)\n    );\n    let hash_unique:[u8;32] = get_unique_hash(\n        pub_key_x,\n        pub_key_y,\n        field_to_bytes(action_index),\n        field_to_bytes(token)\n    );\n\n    // the user only need to sign with is private key to generate merkle leaf, so we never reveal private key\n    let valid_signature = std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, signature, hash_message);\n    assert(valid_signature);\n    let valid_signature_unique = std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, signature_unique, hash_unique);\n    assert(valid_signature_unique);\n\n    // we use hash_signature so it will be difficult to guess the hash if we don'r have the private key to sign\n    let hash_signature = std::hash::blake3(signature);\n    let hash_signature_unique = std::hash::blake3(signature_unique);\n\n    // check new leaf match hash generated\n    assert(new_leaf == hash_signature);\n    assert(unique == hash_signature_unique);\n\n    if (action_index == 1) {\n        // the first deposit don't need to prove old actions\n        // if first action so the previous balance is zero\n        assert(old_amount == 0);\n    } else {\n        let oldAction = action_index - 1;\n        // use blake 3 to hash\n        let old_data:[u8;32] = get_leaf_hash(\n            pub_key_x,\n            pub_key_y,\n            field_to_bytes(oldAction),\n            field_to_bytes(token),\n            field_to_bytes(old_amount)\n        );\n        let valid_old_signature = std::ecdsa_secp256k1::verify_signature(pub_key_x, pub_key_y, old_signature, old_data);\n        assert(valid_old_signature, \"Invalid old signature\");\n        let old_leaf = std::hash::blake3(old_signature);\n        let computed_root = compute_merkle_root(old_leaf, leaf_index, witnesses);\n        assert(computed_root == merkle_root);\n    }\n}\n\n// update of noir implementation to use sha (best ratio perf/gas for solidity)\nfn compute_merkle_root<N>(leaf: [u8; 32], index: Field, hash_path: [[u8; 32]; N]) -> [u8; 32] {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        let mut arr:[u8;64]= [0; 64];\n        for i in 0..32 {\n            arr[i] = hash_left[i];\n            arr[i+32]=hash_right[i];\n        }\n        current = std::hash::sha256(arr);\n    }\n    current\n}\n\nfn field_to_bytes(input: Field) -> [u8; 32] {\n    let input_to_bytes:[u8] = input.to_be_bytes(32);\n    let mut result :[u8;32] = [0; 32];\n    for i in 0..32 {\n        result[i] = input_to_bytes[i];\n    }\n    result\n}\n\nfn get_leaf_hash(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    action_index: [u8; 32],\n    token: [u8; 32],\n    amount: [u8; 32]\n) -> [u8; 32] {\n    let mut array_concat:[u8;160] = [0; 160];\n\n    for i in 0..32 {\n        array_concat[i] = pub_key_x[i];\n        array_concat[i+32] = pub_key_y[i];\n        array_concat[i+64] = action_index[i];\n        array_concat[i+96] = token[i];\n        array_concat[i+128] = amount[i];\n    }\n    std::hash::blake3(array_concat)\n}\n\nfn get_unique_hash(pub_key_x: [u8; 32], pub_key_y: [u8; 32], action_index: [u8; 32], token: [u8; 32]) -> [u8; 32] {\n    let mut array_concat:[u8;128] = [0; 128];\n\n    for i in 0..32 {\n        array_concat[i] = pub_key_x[i];\n        array_concat[i+32] = pub_key_y[i];\n        array_concat[i+64] = action_index[i];\n        array_concat[i+96] = token[i];\n    }\n    std::hash::blake3(array_concat)\n}\n\n","path":"/home/eddy/pi-wallet/packages/foundry/noir/src/main.nr"}}}